import { useLocation, useNavigate } from "react-router-dom";
import { useState, useContext, useRef, useEffect } from "react";
import { AppContext } from "../context/AppContext";
import { motion, AnimatePresence } from "framer-motion";
import "./Results.css";

export default function Results() {
  const location = useLocation();
  const navigate = useNavigate();
  const { state } = useLocation();
  const { vibePhrase, tracks: initialTracks } = state;

  const [tracks, setTracks] = useState(initialTracks || []);

  const { accessToken, profile } = useContext(AppContext); 
  const [isSaving, setIsSaving] = useState(false);
  const [showPopup, setShowPopup] = useState(false);
  const [playlistUrl, setPlaylistUrl] = useState("");
  const [error, setError] = useState("");
  const [lastRemoved, setLastRemoved] = useState(null); // { track, index }
  const undoTimerRef = useRef(null);

  // Helper: split an array into chunks of given size
  const chunkArray = (arr, size) => {
    const res = [];
    for (let i = 0; i < arr.length; i += size) res.push(arr.slice(i, i + size));
    return res;
  };

  const handleRemove = (indexToRemove) => {
    setTracks((prev) => {
      const removedTrack = prev[indexToRemove];
      const next = prev.filter((_, i) => i !== indexToRemove);
      setLastRemoved({ track: removedTrack, index: indexToRemove });

      if (undoTimerRef.current) clearTimeout(undoTimerRef.current);
      undoTimerRef.current = setTimeout(() => setLastRemoved(null), 6000);

      return next;
    });
  };

  const handleUndoRemove = () => {
    if (!lastRemoved) return;
    const { track, index } = lastRemoved;
    setTracks((prev) => {
      const next = [...prev];
      next.splice(Math.min(index, next.length), 0, track);
      return next;
    });
    setLastRemoved(null);
    if (undoTimerRef.current) clearTimeout(undoTimerRef.current);
  };

  useEffect(() => {
    return () => {
      if (undoTimerRef.current) clearTimeout(undoTimerRef.current);
    };
  }, []);

  const handleSaveMoodsic = () => {
    console.log("Saved in Moodsic:", tracks);
    alert("Playlist saved in Moodsic!");
  };

  const handleSaveSpotify = async () => {
    if (!accessToken || !profile?.id) {
      alert("Please log in with Spotify first!");
      return;
    }
    if (!tracks.length) {
      alert("No tracks to save!");
      return;
    }

    setIsSaving(true);
    setError("");

    try {
      // Convert URLs to Spotify URIs (spotify:track:xxxx)
      const uris = tracks
        .map((t) => {
          const trackId = t.url?.split("/").pop();
          return trackId ? `spotify:track:${trackId}` : null;
        })
        .filter(Boolean);

      if (!uris.length) throw new Error("No valid track URIs found.");

      // Create a playlist
      const createPlaylist = await fetch(
        `https://api.spotify.com/v1/users/${profile.id}/playlists`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${accessToken}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            name: `${vibePhrase}`,
            description: "Generated by Moodsic",
            public: false,
          }),
        }
      );

      if (!createPlaylist.ok) throw new Error("Oops! Failed to create playlist");

      const playlistData = await createPlaylist.json();
      console.log(playlistData)
      const playlistId = playlistData.id;

      // Add tracks in chunks of 50
      const chunks = chunkArray(uris, 50);
      for (const chunk of chunks) {
        const addResp = await fetch(
          `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
          {
            method: "POST",
            headers: {
              Authorization: `Bearer ${accessToken}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ uris: chunk }),
          }
        );
        if (!addResp.ok) throw new Error("Failed to add tracks");
      }

      // Show popup
      setPlaylistUrl(playlistData.external_urls.spotify);
      setShowPopup(true);
    } catch (err) {
      console.error("Save error:", err);
      setError(err.message || "Something went wrong saving to Spotify.");
    } finally {
      setIsSaving(false);
    }
  };

  const handleChart = () => {
    navigate("/chart", { state: { tracks } });
  };

  return (
    <div className="results-container">
      <h1 className="vibe-title">{vibePhrase}</h1>

      <div className="tracks-container">
        {tracks.length && tracks[0].url ? (
          tracks.map((track, index) => (
            <div className="track-wrapper" key={track.url || index}>
              <div className="track-card">
                <iframe
                  title={`track-${index}`}
                  className="spotify-embed"
                  src={`https://open.spotify.com/embed/track/${track.url.split("/").pop()}`}
                  allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"
                  sandbox="allow-same-origin allow-scripts allow-popups allow-forms"
                />
              </div>
              <button
                className="remove-button"
                onClick={() => handleRemove(index)}
              >
                &times;
              </button>
            </div>
          ))
        ) : (
          <p className="no-tracks-message">
            No tracks available for this vibe. Try adjusting your mood, words, or Spotify options!
          </p>
        )}
      </div>

      <div className="results-buttons">
        <button
          className="back-button"
          onClick={() =>
            navigate("/", {
              state: {
                mood: location.state?.mood,
                selectedWords: location.state?.selectedWords,
                usedWeather: location.state?.usedWeather,
                usedPersonality: location.state?.usedPersonality,
                usedSpotify: location.state?.usedSpotify,
              },
            })
          }
        >
          &larr; Try Again!
        </button>

        {/* need implement this */}
        <button className="save-button moodsic" onClick={handleSaveMoodsic}>
          Save in Moodsic
        </button>

        <button
          className="save-button spotify"
          onClick={handleSaveSpotify}
          disabled={isSaving}
        >
          {isSaving ? "Saving..." : "Save to Spotify"}
        </button>

        <button className="see-chart" onClick={handleChart}>
          Go to Dashboard
        </button>
      </div>

      {/* Undo Toast */}
      <AnimatePresence>
        {lastRemoved && (
          <motion.div
            className="undo-toast"
            initial={{ y: 50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            exit={{ y: 50, opacity: 0 }}
            transition={{ type: "spring", stiffness: 250, damping: 22 }}
          >
            <span>Track removed</span>
            <button className="undo-button" onClick={handleUndoRemove}>Undo</button>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Animated Popup */}
      <AnimatePresence>
        {showPopup && (
          <motion.div
            className="popup-overlay"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            <motion.div
              className="popup-card"
              initial={{ scale: 0.8, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.8, opacity: 0 }}
              transition={{ type: "spring", stiffness: 180, damping: 20 }}
            >
              <button className="close-btn" onClick={() => setShowPopup(false)}>
                âœ–
              </button>

              {/* Playlist Name */}
              <h3 className="popup-title" title={vibePhrase}>
                {vibePhrase}
              </h3>

              <p className="popup-text">
                Your playlist has been added to Spotify.
              </p>

              <button
                className="go-button"
                onClick={() => window.open(playlistUrl, "_blank")}
              >
                Go to Spotify
              </button>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      {error && <div className="error-message">{error}</div>}
    </div>
  );
}
